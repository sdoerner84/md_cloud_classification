# -*- coding: utf-8 -*-
"""
Created on Fri Dec 11 16:47:06 2020

@author: Vinod
"""

import os
import numpy as np
import yaml
from scipy.optimize import curve_fit
from scipy.signal import find_peaks
from datetime import datetime, timedelta
import warnings
from validation.tools import plt, nc2dict, netCDF4, return_exp, read_frm4doas_qdoas
from validation.cloud_tools import CloudClassError
warnings.simplefilter('always', UserWarning)


def fitFunc(x, A0, A, mu, sigma):
    return A0 + A*np.exp(-((x-mu)**2/(2.*sigma**2)))


def convert_dt(dt):
    return datetime.strptime(str(dt), '%Y%m%d%H%M%S')


def convert_fractional_day(day, year):
    if year > 3000:
        return datetime(1, 1, 1)
    return datetime(year, 1, 1) + timedelta(days=day)


def test_exclusive(x):
    assert sum(x[:5]) <= 1, "Primary cloud classification should be \\\
        mutually exclusive"


def flag_to_bin(x):
    bin_x = x[0]*1e7+x[1]*1e6+x[2]*1e5+x[3]*1e4
    bin_x += x[4]*1e3+x[5]*1e2+x[6]*10+x[7]
    return int(str(int(bin_x)), 2)


class CloudClassification():
    def __init__(self, inp_files, source='mapanc', **kwargs):
        '''
        Parameters
        ----------
        mapa_inp_files : lit
             Paths of mapa input files.
        **kwargs :
            config_data; Site specific data configuration.

        Returns
        -------
        None.

        '''
        self.inp_files = inp_files
        self.calibration_CI_scale = kwargs.get('calibration_CI_scale', None)
        config_data = kwargs.get('config_data',
                                 '../configuration/config_data_mohali.yml')
        threshold_data = kwargs.get('threshold_data',
                                    '../configuration/config_threshold.yml')
        with open(config_data) as conf_file:
            Inp = yaml.safe_load(conf_file)
        with open(threshold_data) as conf_file:
            Inp.update(yaml.safe_load(conf_file))
        Inp['site'] = kwargs.get('site', Inp['site'])
        Inp['O4_dSCD_MAPA'] = kwargs.get('O4_dSCD_MAPA', Inp['O4_dSCD_MAPA'])
        self.Inp = Inp
        # Put some standard values:
        if 'zenith_elev' not in self.Inp:
            self.Inp['zenith_elev'] = 90.0
        if 'max_sza' not in self.Inp:
            self.Inp['max_sza'] = 60.0
        self.source = source
        if source == 'mapanc':
            self.read_mapa_converter_input(**kwargs)
        elif source == 'frm4doas':
            self.read_frm4doas_qdoas_input(**kwargs)
        else:
            err_msg = f'Input source {source} is not defined. Valid input '
            err_msg += 'types currently are: mapanc and frm4doas'
            raise CloudClassError(err_msg)

    def read_mapa_converter_input(self, **kwargs):
        '''
        Reading conventional mapa input files generated by the MAPA Converter
        '''
        CI = []
        SZA = []
        o4_dAMF = []
        self.counter = [0]
        date_time = []
        for fl_counter, fl_now in enumerate(self.inp_files):
            data = nc2dict(fl_now)
            # Before doing anything, set all radiance to NAN when SZA is too high
            self.SZAlim = kwargs.get('SZAlim', None)
            if self.SZAlim is None:
                self.SZAlim = 75
            sza_filter = data['measurement_info']['sza'] > self.SZAlim
            data['aerosol'][self.Inp['O4_dSCD_MAPA']]['value'][sza_filter] *= np.nan
            for radkey in data['radiance']:
                data['radiance'][radkey]['value'][sza_filter] *= np.nan
            # Radiances and O4 SCD set to nan...
            elev = data['measurement_info']['elevation_angle']
            # ignore user specific elevation angles
            keep = [i for i, val in enumerate(elev)
                    if np.all(val != np.array(self.Inp['ignore_elev']))]
            o4_dSCD = data['aerosol'][self.Inp['O4_dSCD_MAPA']]['value']
            # Find all NaN elevation angles
            discard = [i for i, val in enumerate(elev)
                       if np.isnan(o4_dSCD[:, i]).all()]
            if len(discard) > 0:
                warning_string = f'All NaN Values for EAs {elev[discard]} in '
                warning_string += f'file {os.path.basename(fl_now)} '
                warnings.warn(warning_string)
            keep = [i for i in keep if i not in discard]
            # Check if valid EIs changed between files
            if fl_counter == 0:
                self.elev = elev[keep]
            else:
                if sorted(self.elev) != sorted(elev[keep]):
                    message = 'valid EAs changed from {self.elev} '
                    message += f'to {elev[keep]} for file '
                    message += os.path.basename(fl_now)
                    raise ValueError(message)
            idx_zenith = np.where(self.elev == self.Inp['zenith_elev'])[0][0]
            self.idx_zenith = idx_zenith
            SZA_keep = data['measurement_info']['sza'][:, keep]
            SZA.extend(SZA_keep[:, self.idx_zenith])
            date_time.extend(np.max(data['measurement_info']['time'][:], axis=1))
            rad_330 = data['radiance']['rad_330']['value'][:, keep]
            if self.Inp['site'] == 'BREMEN':
                rad_390 = data['radiance']['rad_387']['value'][:, keep]
            else:
                rad_390 = data['radiance']['rad_390']['value'][:, keep]
            self.rad_330 = rad_330
            self.rad_390 = rad_390
            CI.extend(rad_330/rad_390)
            o4_dSCD = o4_dSCD[:, keep]
            o4_dAMF.extend(o4_dSCD/data['auxiliary']['o4vcd'][:, None])
            self.counter.append(self.counter[-1]+len(rad_330))
        self.SZA = np.asarray(SZA)
        self.CI = np.asarray(CI)
        self.o4_dAMF = np.asarray(o4_dAMF)
        self.calc_OT_cloud = True
        if np.isnan(self.o4_dAMF[:, self.idx_zenith]).all():
            warning_string = f'All NaN O4 dSCDs for zenith EA in {fl_now}'
            warning_string += '\n Only primary cloud classification possible'
            warnings.warn(warning_string)
            self.calc_OT_cloud = False
        self.date_time = np.vectorize(convert_dt)(date_time)
        self.TH_dict = {}
        self.ctype = None
        # if user wants to manually provide the CI calibration value
        self.calibration_CI_scale = kwargs.get('calibration_CI_scale', None)

    def read_frm4doas_qdoas_input(self, **kwargs):
        '''
        Reading conventional frm4doas input files
        '''
        CI = []
        SZA = []
        o4_dAMF = []
        self.counter = [0]
        date_time = []
        for fl_counter, fl_now in enumerate(self.inp_files):
            zenith = self.Inp['zenith_elev']
            data = read_frm4doas_qdoas(fl_now, zenith)
            # Before doing anything, set all radiance to NAN when SZA is too high
            self.SZAlim = kwargs.get('SZAlim', None)
            if self.SZAlim is None:
                self.SZAlim = 75
            sza_filter = data['sza'] > self.SZAlim
            for keys in data.keys():
                if keys == 'time':
                    continue
                data[keys][sza_filter] *= np.nan
            # Radiances and O4 SCD set to nan...
            elev = np.unique(data['elev'][~np.isnan(data['elev'])])
            # insert zenith angle in first position to be consistent with
            # sequence definition
            elev = np.insert(elev, 0, zenith)
            # ignore user specific elevation angles
            keep = [i for i, val in enumerate(elev)
                    if np.all(val != np.array(self.Inp['ignore_elev']))]
            o4_dSCD = data['o4_dSCD']
            # Find all NaN elevation angles
            discard = [i for i, val in enumerate(elev)
                       if np.isnan(o4_dSCD[:, i]).all()]
            if len(discard) > 0:
                warning_string = f'All NaN Values for EAs {elev[discard]} in '
                warning_string += f'file {os.path.basename(fl_now)} '
                warnings.warn(warning_string)
            keep = [i for i in keep if i not in discard]
            # Check if valid EIs changed between files
            if fl_counter == 0:
                self.elev = elev[keep]

            else:
                if sorted(self.elev) != sorted(elev[keep]):
                    message = 'valid EAs changed from {self.elev} '
                    message += f'to {elev[keep]} for file '
                    message += os.path.basename(fl_now)
                    raise ValueError(message)
            idx_zenith = len(self.elev)-1  # last element is always zenith angle
            self.idx_zenith = idx_zenith
            SZA_keep = data['sza'][:, keep]
            SZA.extend(SZA_keep[:, self.idx_zenith])
            max_time = [max([t for t in row if isinstance(t, str)],
                            default=np.nan) for row in data['time']]
            date_time.extend(max_time)
            rad_330 = data['rad330'][:, keep]
            rad_390 = data['rad390'][:, keep]
            self.rad_330 = rad_330
            self.rad_390 = rad_390
            CI.extend(rad_330/rad_390)
            o4_dSCD = o4_dSCD[:, keep]
            if 'o4_VCD' not in kwargs:
                o4_VCD = 1.43e43
            o4_dAMF.extend(o4_dSCD/o4_VCD)
            self.counter.append(self.counter[-1]+len(rad_330))
        self.SZA = np.asarray(SZA)
        self.CI = np.asarray(CI)
        self.o4_dAMF = np.asarray(o4_dAMF)
        self.calc_OT_cloud = True
        if np.isnan(self.o4_dAMF[:, self.idx_zenith]).all():
            warning_string = f'All NaN O4 dSCDs for zenith EA in {fl_now}'
            warning_string += '\n Only primary cloud classification possible'
            warnings.warn(warning_string)
            self.calc_OT_cloud = False
        self.date_time = np.vectorize(convert_dt)(date_time)
        self.TH_dict = {}
        self.ctype = None
        # if user wants to manually provide the CI calibration value
        self.calibration_CI_scale = kwargs.get('calibration_CI_scale', None)


    def gen_thresholds(self):
        if self.TH_dict:
            return self.TH_dict
        else:
            s_norm = self.SZA/self.Inp['zenith_elev']
            TH_dict = {}
            for th_now in ['CI_AOD02', 'AVG_SZA', 'CI_CSR', 'CI_TH', 'CI_MIN',
                           'TSI_TH', 'O4_TH', 'O4_DIFF_TH', 'SPREAD_CI',
                           'SPREAD_O4']:
                poly_temp = np.poly1d(self.Inp[th_now])
                TH_dict[th_now] = poly_temp(s_norm)
                if th_now == 'CI_AOD02':
                    TH_dict[th_now] = poly_temp(self.SZA)
                if th_now == 'AVG_SZA':
                    TH_dict[th_now] = poly_temp(self.SZA)
                if th_now == 'TSI_TH':
                    TH_dict[th_now] /= TH_dict['CI_AOD02']
                    TH_dict[th_now] *= 0.06
                    TH_dict[th_now] *= 2.5
            self.TH_dict = TH_dict
            return TH_dict

    def normalize_CI(self, **kwargs):
        method = kwargs.get("method", "peak_finding")
        # methods options "Gauss_fit" or "peak_finding"
        if self.calibration_CI_scale is None:
            TH = self.gen_thresholds()
            CI_Norm = self.CI[:, self.idx_zenith]/TH['CI_MIN']
            n_bins = np.arange(0, 3.02, 0.02)
            # First gauss fit to clip
            select_CI = CI_Norm[self.SZA < self.Inp['max_sza']]
            count_abs, bins = np.histogram(select_CI, n_bins)
            count = count_abs/np.sum(count_abs)
            fig, ax = plt.subplots(figsize=[8, 4])
            ax.plot(bins[:-1], count, c='k', alpha=0.7,
                    label='CI distribution')
            # Check if CI values are normally distributed
            try:
                p0 = [0, np.nanmax(count), n_bins[np.argmax(count)], 0.2]
                fitParams, _ = curve_fit(fitFunc, bins[:-1], count, p0)
            except RuntimeError:
                message = 'CI not normally distributed.'
                message += '\n Please check radiance values'
                plt.show()
                raise ValueError(message)
            if method == "Gauss_fit":
                # Final gauss fit after clipping
                keep = (self.SZA < self.Inp['max_sza'])
                keep &= (CI_Norm < fitParams[2]+fitParams[3])
                count_, bins = np.histogram(CI_Norm[keep], n_bins)
                count_ = count_/np.sum(count_abs)
                fitParams, _ = curve_fit(fitFunc, bins[:-1], count_, p0)
                fit_line = fitFunc(bins[:-1], fitParams[0], fitParams[1],
                                   fitParams[2], fitParams[3])
                calibration_CI_scale = 1/fitParams[2]
                ax.plot(bins[:-1], fit_line, '-', color='r', label='Gauss fit')
            else:
                peaks, _ = find_peaks(count, prominence=0.05*np.max(count))
                ax.scatter(bins[peaks], count[peaks], marker='o', s=24,
                           facecolor="none", edgecolor='b', label='All peaks')
                peaks_new = peaks[count[peaks] > 0.1*np.max(count[peaks])]
                ax.scatter(bins[peaks_new], count[peaks_new], marker='x',
                           c='r', s=24, label='$>$ 0.1 * max')
                ax.axvline(bins[np.min(peaks_new)], color='r',
                           label='CI calib. value')
                calibration_CI_scale = 1/bins[np.min(peaks_new)]
            frac_lower = np.sum(count[bins[:-1] < (1/calibration_CI_scale)])
            CI_message = 'CI scaled calibration value is '
            CI_message += str(calibration_CI_scale) + '\n'
            CI_message += 'Fraction of CI below threshold is '
            CI_message += str(frac_lower)
            print(CI_message)
            ax.legend(loc='upper right')
            ax.set_xlabel('Normalized CI')
            ax.set_ylabel('Relative frequency')
            ax.annotate(self.Inp['site'], xy=(0.02, 0.9),
                        xycoords='axes fraction')
            ax.annotate('Fraction of CI\nbelow threshold: {0:.2f}%'.format(frac_lower*100),
                        xy=(0.02, 0.8), xycoords='axes fraction')
            ax.grid(alpha=0.4)
            plt.tight_layout()
            plt.savefig('CI_normalization.png', dpi=200, format='png')
            if kwargs['verbose']:
                plt.show()
            else:
                plt.close()
            self.calibration_CI_scale = calibration_CI_scale
        return self.calibration_CI_scale

    def calc_spread(self, param, scale=1):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=RuntimeWarning)
            spread = (np.nanmax(param, axis=1) - np.nanmin(param, axis=1))
        spread *= scale

        # %% Normalize spread for SZA dependence
        spread /= self.TH['AVG_SZA']
        return spread

    def calc_TSI(self, elevation=None):
        if elevation is None:
            elevation = self.Inp['zenith_elev']
        elev_idx = np.where(self.elev == elevation)[0][0]
        calibration_CI_scale = self.normalize_CI()
        date_arr = np.asarray([i.date() for i in self.date_time])
        dates = np.unique(date_arr)

        # %% 2024er TSI calculation and normalization
        # %% for new sequence definition
        if self.source == 'frm4doas':
            CI_scaled = self.CI * calibration_CI_scale
            CI_scaled /= self.TH['CI_AOD02'].reshape(-1, 1)
            TSI_scaled = np.zeros((len(self.SZA), CI_scaled.shape[1]))
            for day in dates:
                seq_day = np.where(date_arr == day)[0]
                TSI_scaled = abs(CI_scaled[seq_day][:, 0]
                                 - CI_scaled[seq_day][:, -1])
        elif self.source == 'mapanc':
            TSI_scaled = np.zeros(len(self.SZA))
            CI_scaled = self.CI[:, elev_idx] * calibration_CI_scale
            CI_scaled /= self.TH['CI_AOD02']
            for day in dates:
                idx_day = np.where(date_arr == day)[0]
                if len(idx_day) > 2:
                    TSI_scaled[idx_day[0]] = 0
                    TSI_scaled[idx_day[-1]] = 0
                    TSI_scaled[idx_day[1:-1]] = abs(CI_scaled[idx_day[1:-1]]
                                                    - CI_scaled[idx_day[:-2]])

        # %% 2016er TSI calculation (mapa)

        # for day in dates:
        #     idx_day = np.where(date_arr == day)[0]
        #     if len(idx_day) > 2:
        #         TSI_scaled[idx_day[0]] = 0
        #         TSI_scaled[idx_day[-1]] = 0
        #         TSI_scaled[idx_day[1:-1]] = abs((CI_scaled[idx_day[:-2]] +
        #                                          CI_scaled[idx_day[2:]])/2-CI_scaled[idx_day[1:-1]])

        return TSI_scaled

    def classify_cloud(self, verbose=True):
        # primary cloud classification
        self.TH = self.gen_thresholds()
        # if accumulation point of CI is not provided manually
        if self.calibration_CI_scale is None:
            self.calibration_CI_scale = self.normalize_CI(verbose=verbose)
        CI_scaled = self.CI[:, self.idx_zenith] * self.calibration_CI_scale
        spread_CI = self.calc_spread(self.CI, self.calibration_CI_scale)
        TSI_scaled = self.calc_TSI()
        # primary cloud classification
        ctype = -1*np.zeros((len(self.SZA), 8))
        # clear sky low aerosol
        idx1 = (CI_scaled >= self.TH['CI_TH']) & (TSI_scaled < self.TH['TSI_TH'])
        ctype[idx1, 0] = 1
        # clear sky high aerosol
        idx2 = (CI_scaled < self.TH['CI_TH']) & (TSI_scaled < self.TH['TSI_TH'])
        idx2 &= (spread_CI >= self.TH['SPREAD_CI'])
        ctype[idx2, 1] = 1
        # cloud holes
        idx3 = (CI_scaled >= self.TH['CI_TH']) & (TSI_scaled >= self.TH['TSI_TH'])
        ctype[idx3, 2] = 1
        # broken clouds
        idx4 = (CI_scaled < self.TH['CI_TH']) & (TSI_scaled >= self.TH['TSI_TH'])
        ctype[idx4, 3] = 1
        # continuous clouds
        idx5 = (CI_scaled < self.TH['CI_TH']) & (TSI_scaled < self.TH['TSI_TH'])
        idx5 &= (spread_CI < self.TH['SPREAD_CI'])
        ctype[idx5, 4] = 1
        # Save indices for plotting
        self.CI_scaled = CI_scaled
        self.TSI_scaled = TSI_scaled
        self.spread_CI = spread_CI
        if not self.calc_OT_cloud:
            self.ctype = ctype
            return ctype
        # secondary cloud classification
        spread_O4 = self.calc_spread(self.o4_dAMF)
        # fog
        idx6 = (CI_scaled < self.TH['CI_TH']) & (spread_O4 < self.TH['SPREAD_O4'])
        ctype[idx6, 5] = 1
        # O4 consistency (zenith)
        zenith_o4 = self.o4_dAMF[:, self.idx_zenith]
        zenith_o4_diff = np.array([0])  # Set first entry to 0 (no warn)
        zenith_o4_diff = np.append(zenith_o4_diff,
                                   zenith_o4[1:] - zenith_o4[:-1])
        zenith_o4_reldiff = np.abs(zenith_o4_diff) / zenith_o4
        idx8 = (zenith_o4_reldiff > self.TH['O4_DIFF_TH'])
        # ctype[idx8, 7] = 1

        # O4 calibration
        if self.Inp['Thick_cloud_method'] == 'O4':
            # idx_o4_calib = (ctype[:, 0] <= 3)
            if self.calc_OT_cloud:
                idx_o4_calib = (ctype[:, 3] == 0) & (ctype[:, 4] == 0)
                idx_o4_calib &= (self.SZA > 30) & (self.SZA < 60)
                data_o4_norm = self.o4_dAMF[:, self.idx_zenith] - self.TH['O4_TH']
                data_o4_norm = data_o4_norm[idx_o4_calib]
                # idx_o4_calib &= np.isfinite(data_o4_norm) & (data_o4_norm < 1e90)
                n_bins = np.arange(-3, 3.01, 0.01)
                count, bins = np.histogram(data_o4_norm, n_bins)
                count = count/np.sum(count)
                p0 = [0, np.max(count), n_bins[np.argmax(count)], 0.1]
                fitParams, fitCov = curve_fit(fitFunc, bins[:-1], count, p0)
                fit_line = fitFunc(bins[:-1], fitParams[0], fitParams[1],
                                   fitParams[2], fitParams[3])
                self.calibration_O4_FRS = np.negative(fitParams[2])
                print('O4 FRS AMF is ' + str(self.calibration_O4_FRS))
                fig, ax = plt.subplots()
                ax.plot(bins[:-1], count, color='k', alpha=0.7,
                        label='O4 AMF distribution')
                ax.plot(bins[:-1], fit_line, '-', color='r', label='Gauss fit')
                ax.legend(loc='upper right')
                ax.set_xlabel('Difference of measured O$_{4}$ DAMF'
                              'and O$_{4}$ Threshold')
                ax.set_ylabel('Relative frequency')
                ax.grid(alpha=0.4)
                plt.tight_layout()
                plt.savefig('O4_calibration.png', dpi=200, format='png')
                if verbose:
                    plt.show()
                plt.close(fig)
                O4_AMF = self.o4_dAMF[:, self.idx_zenith] + self.calibration_O4_FRS
                # Thick clouds
                # idx7 = (ctype[:, 0] >= 4) & (O4_AMF > TH['O4_TH'] + 0.85)
                idx7 = (ctype[:, 3] >= 1) | (ctype[:, 4] >= 1)
                idx7 &= (O4_AMF > self.TH['O4_TH'] + 0.85)
                ctype[idx7, 6] = 1
        # Derive cloud flag
        total_class = np.array([flag_to_bin(x) for x in ctype])
        # change_id = total_class[:-1] != total_class[1:]
        # change_id = np.append([False], change_id)
        # ctype[change_id, 7] = 1

        # Check if 3 classifications are not the same
        change_id = (total_class[:-2] != total_class[1:-1]) | (total_class[1:-1] != total_class[2:])
        change_id_first = total_class[0] != total_class[1]
        change_id_last = total_class[-2] != total_class[-1]
        change_id = np.append(change_id_first, change_id)
        change_id = np.append(change_id, change_id_last)
        ctype[change_id, 7] = 1

        self.ctype = ctype
        # Test for mutually exclusive primary cloud classifcation
        for ctype_now in ctype:
            test_exclusive(ctype_now)
        return ctype

    def calc_frac(self, verbose=True):
        if self.ctype is None:
            self.classify_cloud(verbose=verbose)
        ctype = self.ctype
        Freq = [len(ctype[:, i][ctype[:, i] == 1])/len(ctype[:, 0])
                for i in range(5)]
        Freq.append(len(ctype[:, 5][ctype[:, 5] == 1])/len(ctype[:, 0]))
        Freq.append(len(ctype[:, 6][ctype[:, 6] == 1])/len(ctype[:, 0]))
        print('Percentage of\nclear sky low aerosols : ' + str(Freq[0]*100)
              + '\nclear sky high aerosol : ' + str(Freq[1]*100)
              + '\ncloud holes : ' + str(Freq[2]*100)
              + '\nbroken clouds : ' + str(Freq[3]*100)
              + '\ncontinuous clouds : ' + str(Freq[4]*100)
              + '\nfog : ' + str(Freq[5]*100)
              + '\nOptically thick clouds : ' + str(Freq[6]*100))

    def append_cloud_class(self):
        if self.ctype is None:
            self.classify_cloud()
        ctype = self.ctype

        ctype = [flag_to_bin(x) for x in ctype]

        annotation = "please convert to bits of base 2\n"
        annotation += "8 digit binary flag for cloud classification\n"
        annotation += "First digit - clear sky with low aerosols,\n"
        annotation += "Second digit - clear sky with high aerosols,\n"
        annotation += "Third digit - cloud holes,\n"
        annotation += "Fourth digit - broken clouds,\n"
        annotation += "Fifth digit - continuous clouds,\n"
        annotation += "Sixth digit - Fog,\n"
        annotation += "Seventh digit - Optically thick clouds,\n"
        annotation += "Eighth digit - Changing flag,\n"
        annotation += "No classification: 00000000"
        file_count = 0
        counter = self.counter
        var_name_cc = 'measurement_info/cloud_classification'
        for fl_now in self.inp_files:
            with netCDF4.Dataset(fl_now, 'r+') as mapa_in:
                if 'cloud_classification' not in mapa_in['measurement_info'].variables:
                    var_cc = mapa_in.createVariable(var_name_cc,
                                                    'u1', 'dim_sequences',
                                                    fill_value=0)
                    var_cc.description = annotation
                else:
                    print('Cloud classification done before, rewriting')
                    var_cc = mapa_in[var_name_cc]

                var_cc[:] = ctype[counter[file_count]:counter[file_count+1]]
                var_cc.CI_scale = self.calibration_CI_scale
                if self.calc_OT_cloud:
                    var_cc.O4_ref_AMF = self.calibration_O4_FRS
                file_count += 1

    def append_cloud_class_frm4doas(self):
        if self.ctype is None:
            self.classify_cloud()
        ctype = self.ctype

        ctype = [flag_to_bin(x) for x in ctype]

        annotation = "please convert to bits of base 2\n"
        annotation += "8 digit binary flag for cloud classification\n"
        annotation += "First digit - clear sky with low aerosols,\n"
        annotation += "Second digit - clear sky with high aerosols,\n"
        annotation += "Third digit - cloud holes,\n"
        annotation += "Fourth digit - broken clouds,\n"
        annotation += "Fifth digit - continuous clouds,\n"
        annotation += "Sixth digit - Fog,\n"
        annotation += "Seventh digit - Optically thick clouds,\n"
        annotation += "Eighth digit - Changing flag,\n"
        annotation += "No classification: 00000000"
        var_name_cc = 'RADIANCE/GEODATA/cloud_classification'
        for fl_now in self.inp_files:
            with netCDF4.Dataset(fl_now, 'r+') as frm4doasin:
                var_name = frm4doasin['RADIANCE']['GEODATA'].variables
                if 'cloud_classification' not in var_name:
                    dim = 'number_of_records'
                    var_cc = frm4doasin.createVariable(var_name_cc,
                                                       datatype='i4',
                                                       dimensions=dim,
                                                       fill_value=0)
                    var_cc.description = annotation
                else:
                    print('Cloud classification done before, rewriting')
                    var_cc = frm4doasin[var_name_cc]

                sequence_ids = frm4doasin['RADIANCE']['GEODATA']['sequence_id'][:]
                # Find position of sequence number
                ctype_counter = 0
                for sequence in np.unique(sequence_ids):
                    indices = np.where(sequence_ids == sequence)[0][0]
                    # Set ctype at position
                    if ctype_counter < len(ctype):
                        var_cc[indices] = ctype[ctype_counter]
                    ctype_counter += 1

                var_cc.CI_scale = self.calibration_CI_scale
                if self.calc_OT_cloud:
                    var_cc.O4_ref_AMF = self.calibration_O4_FRS

    def save_csv_out(self, savename):
        if self.ctype is None:
            self.classify_cloud()
        data_cloud_classified = np.c_[self.date_time, self.SZA,
                                      self.ctype[:, 0:8]]
        header = 'Cloud classification results using MAPA tool with\n'
        header += 'CI_scale = ' + str(self.calibration_CI_scale) + '\n'
        header += 'and O4_ref_AMF = ' + str(self.calibration_O4_FRS) + '\n'
        header += 'Date_time, SZA, clear_sky_low_aerosol, '
        header += 'clear_sky_high_aerosol, cloud_holes, broken_clouds, '
        header += 'continuous clouds, fog, Thick clouds_o4, Change Flag'
        np.savetxt(savename, data_cloud_classified, delimiter=',',
                   fmt=('%s', '%.3f', '%i', '%i', '%i', '%i', '%i', '%i', '%i', '%i'),
                   header=header)


def decode_cloud(mapa_inp_file):
    '''
    Separates primary and secodary cloud classification from
    cloud classified MAPA input file and returns a dictionary with three keys
    Pirmary cloud classification:
        1 - Clear sky with low aerosol
        2 - Clear sky with high aerosol
        3 - Cloud holes
        4 - Broken clouds
        5 - Continuous clouds
    Secondaty clould classfication
        fog  - 1 indicates presence of fog
        ot_cloud - 1 indicates presence of optically thick cloud
    '''

    outdict = {'cloud_type': [], 'fog': [], 'ot_cloud': []}
    with netCDF4.Dataset(mapa_inp_file) as f:
        cloud_bin = f['measurement_info/cloud_classification'][:]
        cloud_bin = [bin(i)[2:].zfill(8) for i in cloud_bin.filled(0)]
        c_type = [return_exp(int(i[:-3]), 10) for i in cloud_bin]
        outdict['cloud_type'].extend(c_type)
        outdict['fog'].extend(int(i[-3]) for i in cloud_bin)
        outdict['ot_cloud'].extend(int(i[-2]) for i in cloud_bin)
    return outdict
